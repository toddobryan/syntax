/**
 * LR parser for Dart generated by the Syntax tool.
 *
 * https://www.npmjs.com/package/syntax-cli
 *
 *   npm install -g syntax-cli
 *
 *   syntax-cli --help
 *
 * To regenerate run:
 *
 *   syntax-cli \
 *     --grammar ~/path-to-grammar-file \
 *     --mode LALR1 \
 *     --output ~/ParserClassName.dart
 */
import 'dart:collection';

{{{MODULE_INCLUDE}}}

/*

The `ParserEvents` class allows defining hooks for certain parse events,
such as initialization of the parser instance, beginning of the parsing, etc.

Default implementation:

  class ParserEvents {
    public static void init() {
      // Parser is created.
    }

    public static void onParseBegin(String _string) {
      // Parsing is started.
    }

    public static void onParseEnd(Object _result) {
      // Parsing is completed.
    }
  }

*/

{{{PARSER_EVENTS_CLASS}}}

{{{TOKENIZER}}}

// --------------------------------------------
// Parser.

class StackEntry {
  StackEntry(this.symbol, this.semanticValue, this.loc);

  int symbol;
  Object? semanticValue;
  YyLoc? loc;
}

/// Base class for the parser. Implements LR parsing algorithm.
/// Should implement at least the following API:
///   parse(String StringToParse): object
///   setTokenizer(Tokenizer tokenizer): void, or equivalent Tokenizer
///       accessor property with a setter.
class {{{PARSER_NAME}}} {
  /**
   * Constructor.
   */
  {{{PARSER_NAME}}}() {
    ParserEvents.init();
  }

  Tokenizer tokenizer = Tokenizer();

  /// Encoded grammar productions table.
  /// Format of a record:
  /// [<Non-Terminal Index>, <RHS.Length>]
  /// Non-terminal indices are 0-Last Non-terminal. LR-algorithm uses
  /// length of RHS to pop symbols from the stack; this length is stored
  /// as the second element of a record. The last element is an optional
  /// name of the semantic action handler. The first record is always
  /// a special marker [-1, -1] entry representing an augmented production.
  static List<List<int> mProductions = [
    {{{PRODUCTIONS}}}
  ];

  /// Cache for the handler methods.
  /// mProductionHandlerMethods[i] is a lambda that calls the function on a {{PARSER_NAME}}
  static final List<void Function({{PARSER_NAME}})> mProductionHandlerMethods = [
    {{{PRODUCTION_HANDLER_METHODS}}}
  ];  

  /// Actual parsing table. An array of records, where
  /// index is a state number, and a value is a dictionary
  /// from an encoded symbol (number) to parsing action.
  /// The parsing action can be "Shift/s", "Reduce/r", a state
  /// transition number, or "Accept/acc".
  ///
  /// Example:
  ///
  ///  static final List<Map<int, String>> mTable = [
  ///    {0: "1", 3: "s2", 4: "s3"},
  ///    ...
  ///  ];
  static List<Map<Integer, String>> mTable = [
    {{{TABLE}}}
  ];

  /// Parsing stack. Stores instances of StackEntry.
  Stack<StackEntry> mValueStack = Stack<StackEntry>();

  /// States stack.
  Stack<int> mStatesStack = Stack<int>;

  /// __ holds a result value from a production
  /// handler. In the grammar usually used as $$.
  ///
  StackEntry? __;

  /// Production handles. The handlers receive arguments as _1, _2, etc.
  /// The result is always stored in __.
  ///
  /// In grammar:
  ///
  /// { $$ = (Integer)$1 + (Integer)$3 }
  ///
  /// Generated:
  ///
  /// public void _handler0() {
  ///   // Prologue
  ///   StackEntry _3 = mValueStack.pop();
  ///   mValueStack.pop();
  ///   StackEntry _1 = mValueStack.pop();
  ///
  ///   __!.semanticValue = (_1.semanticValue as int) + (_3.semanticValue as int);
  /// }
  {{{PRODUCTION_HANDLERS}}}

  /// Main parsing method which applies LR-algorithm.
  Object? parse(String str) {
    // On parse begin hook.
    ParserEvents.onParseBegin(str);

    tokenizer.initString(str);

    // Initialize the parsing stack to the initial state 0.
    mValueStack = new Stack<StackEntry>();
    mStatesStack = new Stack<Integer>();
    mStatesStack.push(0);

    Token? token = tokenizer.getNextToken();
    Token? shiftedToken = null;

    do {
      if (token == null) {
        unexpectedEndOfInput();
      }
      token!;

      int state = mStatesStack.top();
      int column = token.type;

      if (!mTable.get(state).containsKey(column)) {
        unexpectedToken(token);
        break;
      }

      String entry = mTable[state][column!;

      // ---------------------------------------------------
      // "Shift". Shift-entries always have 's' as their
      // first char, after which goes *next state number*, e.g. "s5".
      // On shift we push the token, and the next state on the stack.
      if (entry.substring(0, 1) == 's') {
        // Push token.
        mValueStack.push(new StackEntry(token.type, token.value, token.loc));

        // Push next state number: "s5" -> 5
        mStatesStack.push(int.parse(entry.substring(1)));

        shiftedToken = token;
        token = tokenizer.getNextToken();
      }

      // ---------------------------------------------------
      // "Reduce". Reduce-entries always have 'r' as their
      // first char, after which goes *production number* to
      // reduce by, e.g. "r3" - reduce by production 3 in the grammar.
      // On reduce, we pop of the stack number of symbols on the RHS
      // of the production, and their pushed state numbers, i.e.
      // total RHS * 2 symbols.
      else if (entry.substring(0, 1) == 'r') {
        // "r3" -> 3
        int productionNumber = int.parse(entry.substring(1));
        List<int> production = mProductions[productionNumber];

        // The length of RHS is stored in the production[1].
        int rhsLength = production[1];
        if (rhsLength != 0) {
          while (rhsLength-- > 0) {
            // Pop the state number.
            mStatesStack.pop();
          }
        }

        int previousState = mStatesStack.top();
        int symbolToReduceWith = production[0];

        __ = StackEntry(symbolToReduceWith, null, null);

        // Execute the semantic action handler.
        this.tokenizer.yytext = shiftedToken?.shiftedToken.value;
        this.tokenizer.yyleng = shiftedToken?.value.length() ?? 0;

        mProductionHandlerMethods[productionNumber](this);
        
        // Then push LHS onto the stack.
        mValueStack.push(__);

        // And the next state number.
        int nextState = int.parse(mTable[previousState][symbolToReduceWith];

        mStatesStack.push(nextState);
      }
      // ---------------------------------------------------
      // Accept. Pop starting production and its state number.
      else if (entry.substring(0, 1) == 'a') {
        // Pop state number.
        mStatesStack.pop();

        // Pop the parsed value.
        StackEntry parsed = mValueStack.pop();

        if (
          mStatesStack.size() != 1 ||
          mStatesStack.peek() != 0 ||
          tokenizer.hasMoreTokens()
        ) {
          unexpectedToken(token);
        }

        Object? parsedValue = parsed.semanticValue;
        ParserEvents.onParseEnd(parsedValue);

        return parsedValue;
      }

    } while (tokenizer.hasMoreTokens() || mStatesStack.size() > 1);

    return null;
  }

  private void unexpectedToken(Token token) throws ParseException {
    if (token.type == Tokenizer.eofToken.type) {
      unexpectedEndOfInput();
    }

    tokenizer.throwUnexpectedToken(
      String.fromCharCode(token.value.codeUnitAt(0)),
      token.loc.startLine,
      token.loc.startColumn
    );
  }

  private void unexpectedEndOfInput() throws ParseException {
    parseError("Unexpected end of input.");
  }

  private void parseError(String message) throws ParseException {
    throw ParseException('Parse error: $message', 0);
  }
}

class ParseException implements Exception {
  ParseException(this.message, this.errorOffset);

  String message;
  int errorOffset;
}